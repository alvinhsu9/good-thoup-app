{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"data\", \"style\", \"containerWidth\", \"itemWidth\", \"itemContainerStyle\", \"separatorWidth\", \"minScrollDistance\", \"inActiveScale\", \"inActiveOpacity\", \"inverted\", \"initialIndex\", \"bounces\", \"showsHorizontalScrollIndicator\", \"keyExtractor\", \"renderItem\", \"onScrollEnd\", \"onScrollBeginDrag\", \"onScrollEndDrag\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React, { Component, useEffect, useImperativeHandle, useRef, useState, forwardRef } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport FlatList from \"react-native-web/dist/exports/FlatList\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nvar _Dimensions$get = Dimensions.get('window'),\n    windowWidth = _Dimensions$get.width;\n\nvar styles = StyleSheet.create({\n  container: {},\n  itemContainer: {\n    justifyContent: 'center'\n  }\n});\nvar AnimatedFlatList = Animated.createAnimatedComponent(FlatList);\n\nfunction useConstructor() {\n  var callBack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      hasBeenCalled = _useState2[0],\n      setHasBeenCalled = _useState2[1];\n\n  if (hasBeenCalled) {\n    return;\n  }\n\n  callBack();\n  setHasBeenCalled(true);\n}\n\nfunction Carousel(props, ref) {\n  var _props$data = props.data,\n      data = _props$data === void 0 ? [] : _props$data,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {} : _props$style,\n      _props$containerWidth = props.containerWidth,\n      containerWidth = _props$containerWidth === void 0 ? windowWidth : _props$containerWidth,\n      _props$itemWidth = props.itemWidth,\n      itemWidth = _props$itemWidth === void 0 ? 0.9 * windowWidth : _props$itemWidth,\n      _props$itemContainerS = props.itemContainerStyle,\n      itemContainerStyle = _props$itemContainerS === void 0 ? {} : _props$itemContainerS,\n      _props$separatorWidth = props.separatorWidth,\n      separatorWidth = _props$separatorWidth === void 0 ? 10 : _props$separatorWidth,\n      _props$minScrollDista = props.minScrollDistance,\n      minScrollDistance = _props$minScrollDista === void 0 ? 5 : _props$minScrollDista,\n      _props$inActiveScale = props.inActiveScale,\n      inActiveScale = _props$inActiveScale === void 0 ? 0.8 : _props$inActiveScale,\n      _props$inActiveOpacit = props.inActiveOpacity,\n      inActiveOpacity = _props$inActiveOpacit === void 0 ? 0.8 : _props$inActiveOpacit,\n      _props$inverted = props.inverted,\n      inverted = _props$inverted === void 0 ? false : _props$inverted,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$bounces = props.bounces,\n      bounces = _props$bounces === void 0 ? true : _props$bounces,\n      _props$showsHorizonta = props.showsHorizontalScrollIndicator,\n      showsHorizontalScrollIndicator = _props$showsHorizonta === void 0 ? false : _props$showsHorizonta,\n      _props$keyExtractor = props.keyExtractor,\n      keyExtractor = _props$keyExtractor === void 0 ? function (item, index) {\n    return index.toString();\n  } : _props$keyExtractor,\n      _props$renderItem = props.renderItem,\n      renderItem = _props$renderItem === void 0 ? function () {} : _props$renderItem,\n      _props$onScrollEnd = props.onScrollEnd,\n      onScrollEnd = _props$onScrollEnd === void 0 ? function () {} : _props$onScrollEnd,\n      _props$onScrollBeginD = props.onScrollBeginDrag,\n      onScrollBeginDrag = _props$onScrollBeginD === void 0 ? function () {} : _props$onScrollBeginD,\n      _props$onScrollEndDra = props.onScrollEndDrag,\n      onScrollEndDrag = _props$onScrollEndDra === void 0 ? function () {} : _props$onScrollEndDra,\n      otherProps = _objectWithoutProperties(props, _excluded);\n\n  var scrollViewRef = useRef(null);\n  var currentIndexRef = useRef(initialIndex);\n  var scrollXRef = useRef(0);\n  var scrollXBeginRef = useRef(0);\n  var xOffsetRef = useRef(new Animated.Value(0));\n  var handleOnScrollRef = useRef(function () {});\n  var halfContainerWidth = containerWidth / 2;\n  var halfItemWidth = itemWidth / 2;\n  var itemTotalMarginBothSide = getItemTotalMarginBothSide();\n  var containerStyle = [styles.container, {\n    width: containerWidth\n  }, style];\n  var dataLength = data ? data.length : 0;\n  useConstructor(function () {\n    setScrollHandler();\n  });\n  useImperativeHandle(ref, function () {\n    return {\n      scrollToIndex: scrollToIndex\n    };\n  });\n\n  function isLastItem(index) {\n    return index === dataLength - 1;\n  }\n\n  function isFirstItem(index) {\n    return index === 0;\n  }\n\n  function getItemLayout(data, index) {\n    return {\n      offset: getItemOffset(index),\n      length: itemWidth,\n      index: index\n    };\n  }\n\n  function setScrollHandler() {\n    handleOnScrollRef.current = Animated.event([{\n      nativeEvent: {\n        contentOffset: {\n          x: xOffsetRef.current\n        }\n      }\n    }], {\n      useNativeDriver: true,\n      listener: function listener(event) {\n        scrollXRef.current = event.nativeEvent.contentOffset.x;\n      }\n    });\n  }\n\n  function scrollToIndex(index) {\n    if (index < 0 || index >= dataLength) {\n      return;\n    }\n\n    onScrollEnd && onScrollEnd(data[index], index);\n    currentIndexRef.current = index;\n    setTimeout(function () {\n      scrollViewRef.current && scrollViewRef.current.scrollToOffset({\n        offset: getItemOffset(index),\n        animated: true\n      });\n    });\n  }\n\n  function handleOnScrollBeginDrag() {\n    onScrollBeginDrag && onScrollBeginDrag();\n    scrollXBeginRef.current = scrollXRef.current;\n  }\n\n  function handleOnScrollEndDrag() {\n    onScrollEndDrag && onScrollEndDrag();\n\n    if (scrollXRef.current < 0) {\n      return;\n    }\n\n    var scrollDistance = scrollXRef.current - scrollXBeginRef.current;\n    scrollXBeginRef.current = 0;\n\n    if (Math.abs(scrollDistance) < minScrollDistance) {\n      scrollToIndex(currentIndexRef.current);\n      return;\n    }\n\n    if (scrollDistance < 0) {\n      scrollToIndex(currentIndexRef.current - 1);\n    } else {\n      scrollToIndex(currentIndexRef.current + 1);\n    }\n  }\n\n  function getItemTotalMarginBothSide() {\n    var compensatorOfSeparatorByScaleEffect = (1 - inActiveScale) * itemWidth;\n    return separatorWidth - compensatorOfSeparatorByScaleEffect / 2;\n  }\n\n  function getItemOffset(index) {\n    return index * (itemWidth + itemTotalMarginBothSide) - (halfContainerWidth - halfItemWidth);\n  }\n\n  function getAnimatedOffset(index) {\n    if (isFirstItem(index)) {\n      return halfItemWidth;\n    }\n\n    if (isLastItem(index)) {\n      return containerWidth - halfItemWidth;\n    }\n\n    return halfContainerWidth;\n  }\n\n  function getMidPontInterpolate(index, animatedOffset) {\n    return index * (itemWidth + itemTotalMarginBothSide) + halfItemWidth - animatedOffset;\n  }\n\n  function getStartPontInterpolate(index, midPoint) {\n    if (index === 1) {\n      return 0;\n    }\n\n    if (isLastItem(index)) {\n      return (dataLength - 2) * (itemWidth + itemTotalMarginBothSide) + halfItemWidth - halfContainerWidth;\n    }\n\n    return midPoint - itemWidth - itemTotalMarginBothSide;\n  }\n\n  function getEndPointInterpolate(index, midPoint) {\n    if (isFirstItem(index)) {\n      return itemWidth + itemTotalMarginBothSide + halfItemWidth - halfContainerWidth;\n    }\n\n    if (index === dataLength - 2) {\n      return (dataLength - 1) * (itemWidth + itemTotalMarginBothSide) + itemWidth - containerWidth;\n    }\n\n    return midPoint + itemWidth + itemTotalMarginBothSide;\n  }\n\n  function getItemAnimatedStyle(index) {\n    var animatedOffset = getAnimatedOffset(index);\n    var midPoint = getMidPontInterpolate(index, animatedOffset);\n    var startPoint = getStartPontInterpolate(index, midPoint);\n    var endPoint = getEndPointInterpolate(index, midPoint);\n    var animatedOpacity = {\n      opacity: xOffsetRef.current.interpolate({\n        inputRange: [startPoint, midPoint, endPoint],\n        outputRange: [inActiveOpacity, 1, inActiveOpacity]\n      })\n    };\n    var animatedScale = {\n      transform: [{\n        scale: xOffsetRef.current.interpolate({\n          inputRange: [startPoint, midPoint, endPoint],\n          outputRange: [inActiveScale, 1, inActiveScale]\n        })\n      }]\n    };\n    return _objectSpread(_objectSpread({}, animatedOpacity), animatedScale);\n  }\n\n  function getItemMarginStyle(index) {\n    var marginSingleItemSide = itemTotalMarginBothSide / 2;\n\n    if (isFirstItem(index)) {\n      return !!inverted ? {\n        marginLeft: marginSingleItemSide\n      } : {\n        marginRight: marginSingleItemSide\n      };\n    }\n\n    if (isLastItem(index)) {\n      return !!inverted ? {\n        marginRight: marginSingleItemSide\n      } : {\n        marginLeft: marginSingleItemSide\n      };\n    }\n\n    return {\n      marginHorizontal: marginSingleItemSide\n    };\n  }\n\n  function renderItemContainer(_ref) {\n    var item = _ref.item,\n        index = _ref.index;\n    return _jsx(Animated.View, {\n      pointerEvents: 'box-none',\n      style: [styles.itemContainer, itemContainerStyle, {\n        width: itemWidth\n      }, getItemMarginStyle(index), getItemAnimatedStyle(index)],\n      children: renderItem({\n        item: item,\n        index: index\n      })\n    });\n  }\n\n  return _jsx(AnimatedFlatList, _objectSpread(_objectSpread({}, otherProps), {}, {\n    ref: scrollViewRef,\n    data: data,\n    style: containerStyle,\n    horizontal: true,\n    inverted: inverted,\n    bounces: bounces,\n    decelerationRate: 0,\n    initialScrollIndex: initialIndex,\n    automaticallyAdjustContentInsets: false,\n    showsHorizontalScrollIndicator: showsHorizontalScrollIndicator,\n    onScroll: handleOnScrollRef.current,\n    keyExtractor: keyExtractor,\n    getItemLayout: getItemLayout,\n    renderItem: renderItemContainer,\n    onScrollBeginDrag: handleOnScrollBeginDrag,\n    onScrollEndDrag: handleOnScrollEndDrag\n  }));\n}\n\nexport default forwardRef(Carousel);","map":{"version":3,"names":["React","Component","useEffect","useImperativeHandle","useRef","useState","forwardRef","Dimensions","get","windowWidth","width","styles","StyleSheet","create","container","itemContainer","justifyContent","AnimatedFlatList","Animated","createAnimatedComponent","FlatList","useConstructor","callBack","hasBeenCalled","setHasBeenCalled","Carousel","props","ref","data","style","containerWidth","itemWidth","itemContainerStyle","separatorWidth","minScrollDistance","inActiveScale","inActiveOpacity","inverted","initialIndex","bounces","showsHorizontalScrollIndicator","keyExtractor","item","index","toString","renderItem","onScrollEnd","onScrollBeginDrag","onScrollEndDrag","otherProps","scrollViewRef","currentIndexRef","scrollXRef","scrollXBeginRef","xOffsetRef","Value","handleOnScrollRef","halfContainerWidth","halfItemWidth","itemTotalMarginBothSide","getItemTotalMarginBothSide","containerStyle","dataLength","length","setScrollHandler","scrollToIndex","isLastItem","isFirstItem","getItemLayout","offset","getItemOffset","current","event","nativeEvent","contentOffset","x","useNativeDriver","listener","setTimeout","scrollToOffset","animated","handleOnScrollBeginDrag","handleOnScrollEndDrag","scrollDistance","Math","abs","compensatorOfSeparatorByScaleEffect","getAnimatedOffset","getMidPontInterpolate","animatedOffset","getStartPontInterpolate","midPoint","getEndPointInterpolate","getItemAnimatedStyle","startPoint","endPoint","animatedOpacity","opacity","interpolate","inputRange","outputRange","animatedScale","transform","scale","getItemMarginStyle","marginSingleItemSide","marginLeft","marginRight","marginHorizontal","renderItemContainer"],"sources":["C:/Users/miche/OneDrive/Documents/GitHub/good-thoup-app/node_modules/react-native-anchor-carousel/src/carousel.js"],"sourcesContent":["import React, {\n  Component,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n  forwardRef\n} from 'react';\nimport { Animated, StyleSheet, Dimensions, FlatList } from 'react-native';\n\nconst { width: windowWidth } = Dimensions.get('window');\n\nconst styles = StyleSheet.create({\n  container: {},\n  itemContainer: { justifyContent: 'center' }\n});\n\nconst AnimatedFlatList = Animated.createAnimatedComponent(FlatList);\n\nfunction useConstructor(callBack = () => {}) {\n  const [hasBeenCalled, setHasBeenCalled] = useState(false);\n  if (hasBeenCalled) {\n    return;\n  }\n  callBack();\n  setHasBeenCalled(true);\n}\n\nfunction Carousel(props, ref) {\n  const {\n    data = [],\n    style = {},\n    containerWidth = windowWidth,\n    itemWidth = 0.9 * windowWidth,\n    itemContainerStyle = {},\n    separatorWidth = 10,\n    minScrollDistance = 5,\n    inActiveScale = 0.8,\n    inActiveOpacity = 0.8,\n    inverted = false,\n    initialIndex = 0,\n    bounces = true,\n    showsHorizontalScrollIndicator = false,\n    keyExtractor = (item, index) => index.toString(),\n    renderItem = () => {},\n    onScrollEnd = () => {},\n    onScrollBeginDrag = () => {},\n    onScrollEndDrag = () => {},\n    ...otherProps\n  } = props;\n  const scrollViewRef = useRef(null);\n  const currentIndexRef = useRef(initialIndex);\n  const scrollXRef = useRef(0);\n  const scrollXBeginRef = useRef(0);\n  const xOffsetRef = useRef(new Animated.Value(0));\n  const handleOnScrollRef = useRef(() => {});\n  const halfContainerWidth = containerWidth / 2;\n  const halfItemWidth = itemWidth / 2;\n  const itemTotalMarginBothSide = getItemTotalMarginBothSide();\n  const containerStyle = [styles.container, { width: containerWidth }, style];\n  const dataLength = data ? data.length : 0;\n\n  useConstructor(() => {\n    setScrollHandler();\n  });\n\n  useImperativeHandle(ref, () => ({\n    scrollToIndex: scrollToIndex\n  }));\n\n  function isLastItem(index) {\n    return index === dataLength - 1;\n  }\n\n  function isFirstItem(index) {\n    return index === 0;\n  }\n\n  function getItemLayout(data, index) {\n    return {\n      offset: getItemOffset(index),\n      length: itemWidth,\n      index\n    };\n  }\n\n  function setScrollHandler() {\n    handleOnScrollRef.current = Animated.event(\n      [{ nativeEvent: { contentOffset: { x: xOffsetRef.current } } }],\n      {\n        useNativeDriver: true,\n        listener: event => {\n          scrollXRef.current = event.nativeEvent.contentOffset.x;\n        }\n      }\n    );\n  }\n\n  function scrollToIndex(index) {\n    if (index < 0 || index >= dataLength) {\n      return;\n    }\n    onScrollEnd && onScrollEnd(data[index], index);\n    currentIndexRef.current = index;\n    setTimeout(() => {\n      scrollViewRef.current &&\n        scrollViewRef.current.scrollToOffset({\n          offset: getItemOffset(index),\n          animated: true\n        });\n    });\n  }\n\n  function handleOnScrollBeginDrag() {\n    onScrollBeginDrag && onScrollBeginDrag();\n    scrollXBeginRef.current = scrollXRef.current;\n  }\n\n  function handleOnScrollEndDrag() {\n    onScrollEndDrag && onScrollEndDrag();\n    if (scrollXRef.current < 0) {\n      return;\n    }\n    const scrollDistance = scrollXRef.current - scrollXBeginRef.current;\n    scrollXBeginRef.current = 0;\n    if (Math.abs(scrollDistance) < minScrollDistance) {\n      scrollToIndex(currentIndexRef.current);\n      return;\n    }\n    if (scrollDistance < 0) {\n      scrollToIndex(currentIndexRef.current - 1);\n    } else {\n      scrollToIndex(currentIndexRef.current + 1);\n    }\n  }\n\n  function getItemTotalMarginBothSide() {\n    const compensatorOfSeparatorByScaleEffect = (1 - inActiveScale) * itemWidth;\n    return separatorWidth - compensatorOfSeparatorByScaleEffect / 2;\n  }\n\n  function getItemOffset(index) {\n    return (\n      index * (itemWidth + itemTotalMarginBothSide) -\n      (halfContainerWidth - halfItemWidth)\n    );\n  }\n\n  function getAnimatedOffset(index) {\n    if (isFirstItem(index)) {\n      return halfItemWidth;\n    }\n    if (isLastItem(index)) {\n      return containerWidth - halfItemWidth;\n    }\n    return halfContainerWidth;\n  }\n\n  function getMidPontInterpolate(index, animatedOffset) {\n    return (\n      index * (itemWidth + itemTotalMarginBothSide) +\n      halfItemWidth -\n      animatedOffset\n    );\n  }\n  function getStartPontInterpolate(index, midPoint) {\n    if (index === 1) {\n      return 0;\n    }\n    if (isLastItem(index)) {\n      return (\n        (dataLength - 2) * (itemWidth + itemTotalMarginBothSide) +\n        halfItemWidth -\n        halfContainerWidth\n      );\n    }\n    return midPoint - itemWidth - itemTotalMarginBothSide;\n  }\n\n  function getEndPointInterpolate(index, midPoint) {\n    if (isFirstItem(index)) {\n      return (\n        itemWidth + itemTotalMarginBothSide + halfItemWidth - halfContainerWidth\n      );\n    }\n    if (index === dataLength - 2) {\n      return (\n        (dataLength - 1) * (itemWidth + itemTotalMarginBothSide) +\n        itemWidth -\n        containerWidth\n      );\n    }\n    return midPoint + itemWidth + itemTotalMarginBothSide;\n  }\n\n  function getItemAnimatedStyle(index) {\n    const animatedOffset = getAnimatedOffset(index);\n    const midPoint = getMidPontInterpolate(index, animatedOffset);\n    const startPoint = getStartPontInterpolate(index, midPoint);\n    const endPoint = getEndPointInterpolate(index, midPoint);\n    const animatedOpacity = {\n      opacity: xOffsetRef.current.interpolate({\n        inputRange: [startPoint, midPoint, endPoint],\n        outputRange: [inActiveOpacity, 1, inActiveOpacity]\n      })\n    };\n    const animatedScale = {\n      transform: [\n        {\n          scale: xOffsetRef.current.interpolate({\n            inputRange: [startPoint, midPoint, endPoint],\n            outputRange: [inActiveScale, 1, inActiveScale]\n          })\n        }\n      ]\n    };\n    return { ...animatedOpacity, ...animatedScale };\n  }\n\n  function getItemMarginStyle(index) {\n    const marginSingleItemSide = itemTotalMarginBothSide / 2;\n    if (isFirstItem(index)) {\n      return !!inverted\n        ? { marginLeft: marginSingleItemSide }\n        : { marginRight: marginSingleItemSide };\n    }\n    if (isLastItem(index)) {\n      return !!inverted\n        ? { marginRight: marginSingleItemSide }\n        : { marginLeft: marginSingleItemSide };\n    }\n    return { marginHorizontal: marginSingleItemSide };\n  }\n\n  function renderItemContainer({ item, index }) {\n    return (\n      <Animated.View\n        pointerEvents={'box-none'}\n        style={[\n          styles.itemContainer,\n          itemContainerStyle,\n          { width: itemWidth },\n          getItemMarginStyle(index),\n          getItemAnimatedStyle(index)\n        ]}\n      >\n        {renderItem({ item, index })}\n      </Animated.View>\n    );\n  }\n\n  return (\n    <AnimatedFlatList\n      {...otherProps}\n      ref={scrollViewRef}\n      data={data}\n      style={containerStyle}\n      horizontal={true}\n      inverted={inverted}\n      bounces={bounces}\n      decelerationRate={0}\n      initialScrollIndex={initialIndex}\n      automaticallyAdjustContentInsets={false}\n      showsHorizontalScrollIndicator={showsHorizontalScrollIndicator}\n      onScroll={handleOnScrollRef.current}\n      keyExtractor={keyExtractor}\n      getItemLayout={getItemLayout}\n      renderItem={renderItemContainer}\n      onScrollBeginDrag={handleOnScrollBeginDrag}\n      onScrollEndDrag={handleOnScrollEndDrag}\n    />\n  );\n}\n\nexport default forwardRef(Carousel);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}